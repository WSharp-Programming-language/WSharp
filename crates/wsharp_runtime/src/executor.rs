//! Async executor runtime for W#.
//!
//! This module provides a minimal single-threaded executor for running
//! async/await coroutines generated by the W# compiler.
//!
//! The executor is designed to work with coroutine-lowered async functions,
//! which are transformed into state machines at compile time.

use std::cell::RefCell;
use std::collections::VecDeque;
use std::rc::Rc;

/// Unique identifier for a spawned task.
pub type TaskId = u64;

/// The result of polling a coroutine.
///
/// This matches the `PollResult` enum generated by the W# compiler
/// for coroutine state machines.
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum PollResult<T> {
    /// The coroutine is not yet complete and needs to be polled again.
    Pending,
    /// The coroutine has completed with a result.
    Ready(T),
}

impl<T> PollResult<T> {
    /// Returns `true` if the result is `Pending`.
    pub fn is_pending(&self) -> bool {
        matches!(self, PollResult::Pending)
    }

    /// Returns `true` if the result is `Ready`.
    pub fn is_ready(&self) -> bool {
        matches!(self, PollResult::Ready(_))
    }

    /// Converts from `PollResult<T>` to `Option<T>`.
    pub fn into_option(self) -> Option<T> {
        match self {
            PollResult::Ready(v) => Some(v),
            PollResult::Pending => None,
        }
    }

    /// Maps `PollResult<T>` to `PollResult<U>` by applying a function.
    pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> PollResult<U> {
        match self {
            PollResult::Ready(v) => PollResult::Ready(f(v)),
            PollResult::Pending => PollResult::Pending,
        }
    }
}

/// A waker that can be used to notify the executor that a task is ready to make progress.
#[derive(Clone)]
pub struct Waker {
    task_id: TaskId,
    ready_queue: Rc<RefCell<VecDeque<TaskId>>>,
}

impl Waker {
    /// Wake the associated task, marking it as ready to be polled.
    pub fn wake(&self) {
        self.wake_by_ref();
    }

    /// Wake the associated task by reference.
    pub fn wake_by_ref(&self) {
        let mut queue = self.ready_queue.borrow_mut();
        // Avoid duplicate entries in the ready queue
        if !queue.contains(&self.task_id) {
            queue.push_back(self.task_id);
        }
    }
}

impl std::fmt::Debug for Waker {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Waker")
            .field("task_id", &self.task_id)
            .finish()
    }
}

/// Context passed to poll functions.
///
/// Contains a reference to the waker which can be used to re-schedule
/// the current task when it's ready to make progress.
pub struct Context<'a> {
    waker: &'a Waker,
}

impl<'a> Context<'a> {
    /// Create a new context with the given waker.
    pub fn from_waker(waker: &'a Waker) -> Self {
        Self { waker }
    }

    /// Returns a reference to the waker.
    pub fn waker(&self) -> &Waker {
        self.waker
    }
}

/// A trait for types that can be polled to completion.
///
/// This is the W# equivalent of Rust's `Future` trait.
pub trait Pollable {
    /// The type of value produced when the pollable completes.
    type Output;

    /// Attempt to resolve the pollable to a value.
    ///
    /// Returns `PollResult::Ready(value)` if the pollable completed,
    /// or `PollResult::Pending` if more work is needed.
    fn poll(&mut self, ctx: &mut Context<'_>) -> PollResult<Self::Output>;
}

/// A boxed pollable that can be stored in the executor.
type BoxedPollable = Box<dyn FnMut(&mut Context<'_>) -> PollResult<()>>;

/// A spawned task in the executor.
struct Task {
    id: TaskId,
    pollable: BoxedPollable,
}

/// A simple single-threaded async executor.
///
/// The executor maintains a queue of tasks and polls them until completion.
pub struct Executor {
    /// All tasks, indexed by position. `None` means the slot is empty.
    tasks: Vec<Option<Task>>,
    /// Queue of task IDs that are ready to be polled.
    ready_queue: Rc<RefCell<VecDeque<TaskId>>>,
    /// Counter for generating unique task IDs.
    next_id: TaskId,
}

impl Executor {
    /// Create a new executor.
    pub fn new() -> Self {
        Self {
            tasks: Vec::new(),
            ready_queue: Rc::new(RefCell::new(VecDeque::new())),
            next_id: 0,
        }
    }

    /// Spawn a new task in the executor.
    ///
    /// The task will be polled when `run()` or `run_until_complete()` is called.
    pub fn spawn<F>(&mut self, mut pollable: F) -> TaskId
    where
        F: FnMut(&mut Context<'_>) -> PollResult<()> + 'static,
    {
        let id = self.next_id;
        self.next_id += 1;

        let task = Task {
            id,
            pollable: Box::new(move |ctx| pollable(ctx)),
        };

        // Find an empty slot or push to the end
        let slot_index = self.tasks.iter().position(|t| t.is_none());
        match slot_index {
            Some(index) => self.tasks[index] = Some(task),
            None => self.tasks.push(Some(task)),
        }

        // Mark as ready to be polled
        self.ready_queue.borrow_mut().push_back(id);

        id
    }

    /// Spawn a pollable type as a task.
    pub fn spawn_pollable<P>(&mut self, mut pollable: P) -> TaskId
    where
        P: Pollable<Output = ()> + 'static,
    {
        self.spawn(move |ctx| pollable.poll(ctx))
    }

    /// Create a waker for the given task ID.
    fn create_waker(&self, task_id: TaskId) -> Waker {
        Waker {
            task_id,
            ready_queue: Rc::clone(&self.ready_queue),
        }
    }

    /// Poll a single task from the ready queue.
    ///
    /// Returns `true` if a task was polled, `false` if the queue was empty.
    fn poll_one(&mut self) -> bool {
        let task_id = match self.ready_queue.borrow_mut().pop_front() {
            Some(id) => id,
            None => return false,
        };

        // Find the task by ID
        let task_index = self.tasks.iter().position(|t| {
            t.as_ref().map(|task| task.id == task_id).unwrap_or(false)
        });

        let task_index = match task_index {
            Some(index) => index,
            None => return true, // Task was removed, continue
        };

        // Take the task out to poll it
        let mut task = match self.tasks[task_index].take() {
            Some(t) => t,
            None => return true,
        };

        let waker = self.create_waker(task_id);
        let mut ctx = Context::from_waker(&waker);

        let result = (task.pollable)(&mut ctx);

        match result {
            PollResult::Ready(()) => {
                // Task completed, leave slot empty
            }
            PollResult::Pending => {
                // Task not done, put it back
                self.tasks[task_index] = Some(task);
            }
        }

        true
    }

    /// Run the executor until all tasks are complete.
    pub fn run(&mut self) {
        while self.has_pending_tasks() {
            if !self.poll_one() {
                // No tasks ready, but some pending - this is a deadlock
                // In a real implementation, we might wait for external events
                break;
            }
        }
    }

    /// Check if there are any pending (incomplete) tasks.
    pub fn has_pending_tasks(&self) -> bool {
        self.tasks.iter().any(|t| t.is_some())
    }

    /// Run a single pollable to completion, blocking until done.
    ///
    /// This is the main entry point for running an async function from
    /// synchronous code.
    pub fn block_on<T, F>(&mut self, mut pollable: F) -> T
    where
        F: FnMut(&mut Context<'_>) -> PollResult<T>,
    {
        // Create a dedicated waker for this task
        let task_id = self.next_id;
        self.next_id += 1;

        let waker = self.create_waker(task_id);
        let mut ctx = Context::from_waker(&waker);

        loop {
            match pollable(&mut ctx) {
                PollResult::Ready(value) => return value,
                PollResult::Pending => {
                    // Poll other tasks while waiting
                    if !self.poll_one() {
                        // No other tasks, but we're still pending
                        // In a real implementation with I/O, we'd wait here
                        // For now, just keep polling
                    }
                }
            }
        }
    }

    /// Block on a `Pollable` type.
    pub fn block_on_pollable<P>(&mut self, mut pollable: P) -> P::Output
    where
        P: Pollable,
    {
        self.block_on(|ctx| pollable.poll(ctx))
    }
}

impl Default for Executor {
    fn default() -> Self {
        Self::new()
    }
}

/// A simple "immediate" pollable that completes immediately with a value.
pub struct Ready<T>(Option<T>);

impl<T> Ready<T> {
    pub fn new(value: T) -> Self {
        Self(Some(value))
    }
}

impl<T> Pollable for Ready<T> {
    type Output = T;

    fn poll(&mut self, _ctx: &mut Context<'_>) -> PollResult<Self::Output> {
        match self.0.take() {
            Some(v) => PollResult::Ready(v),
            None => panic!("Ready polled after completion"),
        }
    }
}

/// A pollable that never completes (useful for testing).
pub struct Pending<T>(std::marker::PhantomData<T>);

impl<T> Pending<T> {
    pub fn new() -> Self {
        Self(std::marker::PhantomData)
    }
}

impl<T> Default for Pending<T> {
    fn default() -> Self {
        Self::new()
    }
}

impl<T> Pollable for Pending<T> {
    type Output = T;

    fn poll(&mut self, _ctx: &mut Context<'_>) -> PollResult<Self::Output> {
        PollResult::Pending
    }
}

/// A pollable that yields once before completing.
///
/// This is useful for testing cooperative yielding.
pub struct YieldOnce<T> {
    value: Option<T>,
    yielded: bool,
}

impl<T> YieldOnce<T> {
    pub fn new(value: T) -> Self {
        Self {
            value: Some(value),
            yielded: false,
        }
    }
}

impl<T> Pollable for YieldOnce<T> {
    type Output = T;

    fn poll(&mut self, ctx: &mut Context<'_>) -> PollResult<Self::Output> {
        if self.yielded {
            PollResult::Ready(self.value.take().expect("polled after completion"))
        } else {
            self.yielded = true;
            ctx.waker().wake_by_ref();
            PollResult::Pending
        }
    }
}

/// A coroutine state wrapper that can be polled.
///
/// This is used to wrap compiler-generated coroutine state structs.
/// The poll function pointer is provided by the generated code.
pub struct CoroutineHandle<T> {
    /// Pointer to the coroutine state struct.
    state: *mut (),
    /// Poll function: takes state pointer and context, returns PollResult.
    poll_fn: fn(*mut (), &mut Context<'_>) -> PollResult<T>,
    /// Drop function: takes state pointer, cleans up.
    drop_fn: Option<fn(*mut ())>,
}

impl<T> CoroutineHandle<T> {
    /// Create a new coroutine handle.
    ///
    /// # Safety
    /// The caller must ensure that:
    /// - `state` is a valid pointer to coroutine state
    /// - `poll_fn` correctly polls the state
    /// - `drop_fn` (if provided) correctly cleans up the state
    pub unsafe fn new(
        state: *mut (),
        poll_fn: fn(*mut (), &mut Context<'_>) -> PollResult<T>,
        drop_fn: Option<fn(*mut ())>,
    ) -> Self {
        Self {
            state,
            poll_fn,
            drop_fn,
        }
    }
}

impl<T> Pollable for CoroutineHandle<T> {
    type Output = T;

    fn poll(&mut self, ctx: &mut Context<'_>) -> PollResult<Self::Output> {
        (self.poll_fn)(self.state, ctx)
    }
}

impl<T> Drop for CoroutineHandle<T> {
    fn drop(&mut self) {
        if let Some(drop_fn) = self.drop_fn {
            drop_fn(self.state);
        }
    }
}

// FFI exports for the W# runtime to call from generated code

/// Create a new executor (C ABI).
#[unsafe(no_mangle)]
pub extern "C" fn wsharp_executor_new() -> *mut Executor {
    Box::into_raw(Box::new(Executor::new()))
}

/// Destroy an executor (C ABI).
///
/// # Safety
/// The executor pointer must be valid and not used after this call.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn wsharp_executor_destroy(executor: *mut Executor) {
    if !executor.is_null() {
        unsafe { drop(Box::from_raw(executor)) };
    }
}

/// Run the executor until all tasks complete (C ABI).
///
/// # Safety
/// The executor pointer must be valid.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn wsharp_executor_run(executor: *mut Executor) {
    if !executor.is_null() {
        unsafe { (*executor).run() };
    }
}

/// Block on a coroutine poll function (C ABI).
///
/// # Safety
/// All pointers must be valid.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn wsharp_block_on_i64(
    executor: *mut Executor,
    state: *mut (),
    poll_fn: fn(*mut (), *mut ()) -> i64,
) -> i64 {
    if executor.is_null() || state.is_null() {
        return 0;
    }

    // The poll function returns an encoded PollResult:
    // - Negative value means Pending (value is -(1))
    // - Non-negative value means Ready with that value
    let executor = unsafe { &mut *executor };
    let task_id = executor.next_id;
    executor.next_id += 1;

    let waker = executor.create_waker(task_id);
    let mut _ctx = Context::from_waker(&waker);

    loop {
        // Pass context as opaque pointer (for now, we don't use it on C side)
        let result = poll_fn(state, std::ptr::null_mut());

        // Check if result indicates Ready (discriminant check)
        // We use a simple encoding: if the state field at offset 0 equals MAX_STATE, we're done
        // For now, assume non-negative means ready
        if result >= 0 {
            return result;
        }

        // Still pending, keep polling
        // In a real implementation, we'd wait for a wake signal
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_poll_result_pending() {
        let result: PollResult<i32> = PollResult::Pending;
        assert!(result.is_pending());
        assert!(!result.is_ready());
        assert_eq!(result.into_option(), None);
    }

    #[test]
    fn test_poll_result_ready() {
        let result = PollResult::Ready(42);
        assert!(!result.is_pending());
        assert!(result.is_ready());
        assert_eq!(result.into_option(), Some(42));
    }

    #[test]
    fn test_poll_result_map() {
        let result = PollResult::Ready(21);
        let mapped = result.map(|x| x * 2);
        assert_eq!(mapped, PollResult::Ready(42));

        let pending: PollResult<i32> = PollResult::Pending;
        let mapped_pending = pending.map(|x| x * 2);
        assert_eq!(mapped_pending, PollResult::Pending);
    }

    #[test]
    fn test_executor_new() {
        let executor = Executor::new();
        assert!(!executor.has_pending_tasks());
    }

    #[test]
    fn test_executor_spawn_and_run() {
        let mut executor = Executor::new();

        let completed = Rc::new(RefCell::new(false));
        let completed_clone = Rc::clone(&completed);

        executor.spawn(move |_ctx| {
            *completed_clone.borrow_mut() = true;
            PollResult::Ready(())
        });

        assert!(executor.has_pending_tasks());
        executor.run();
        assert!(!executor.has_pending_tasks());
        assert!(*completed.borrow());
    }

    #[test]
    fn test_executor_block_on() {
        let mut executor = Executor::new();

        let result = executor.block_on(|_ctx| PollResult::Ready(42));
        assert_eq!(result, 42);
    }

    #[test]
    fn test_ready_pollable() {
        let mut executor = Executor::new();
        let ready = Ready::new(100);

        let result = executor.block_on_pollable(ready);
        assert_eq!(result, 100);
    }

    #[test]
    fn test_yield_once() {
        let mut executor = Executor::new();
        let yield_once = YieldOnce::new(42);

        let result = executor.block_on_pollable(yield_once);
        assert_eq!(result, 42);
    }

    #[test]
    fn test_multiple_tasks() {
        let mut executor = Executor::new();

        let results = Rc::new(RefCell::new(Vec::new()));

        for i in 0..3 {
            let results_clone = Rc::clone(&results);
            executor.spawn(move |_ctx| {
                results_clone.borrow_mut().push(i);
                PollResult::Ready(())
            });
        }

        executor.run();

        let results = results.borrow();
        assert_eq!(results.len(), 3);
        // All values should be present (order may vary)
        assert!(results.contains(&0));
        assert!(results.contains(&1));
        assert!(results.contains(&2));
    }

    #[test]
    fn test_waker_wake() {
        let mut executor = Executor::new();

        let poll_count = Rc::new(RefCell::new(0));
        let poll_count_clone = Rc::clone(&poll_count);

        executor.spawn(move |ctx| {
            let count = *poll_count_clone.borrow();
            *poll_count_clone.borrow_mut() = count + 1;

            if count < 3 {
                ctx.waker().wake();
                PollResult::Pending
            } else {
                PollResult::Ready(())
            }
        });

        executor.run();

        assert_eq!(*poll_count.borrow(), 4); // Polled 4 times (0, 1, 2, 3)
    }
}
